EXPLICAÇÃO DETALHADA - WEBSOCKETS NO DELIVERY TRACK
===================================================

O QUE SÃO WEBSOCKETS?
=====================
WebSockets são um protocolo de comunicação que permite uma conexão bidirecional e persistente entre cliente (navegador) e servidor. Diferente do HTTP tradicional (request/response), os WebSockets mantêm a conexão aberta, permitindo que tanto o servidor quanto o cliente enviem mensagens a qualquer momento.

POR QUE USAR WEBSOCKETS NO DELIVERY TRACK?
==========================================
1. TEMPO REAL: Atualizações instantâneas da localização do entregador
2. EFICIÊNCIA: Não precisa fazer requisições repetidas (polling)
3. BAIXA LATÊNCIA: Comunicação direta sem overhead de HTTP
4. ESCALABILIDADE: Múltiplos clientes podem acompanhar a mesma entrega

ARQUITETURA DOS WEBSOCKETS NO PROJETO
=====================================

BACKEND (Fastify + WebSocket)
-----------------------------
Localização: backend/src/routes/locations.ts

1. CONFIGURAÇÃO DO WEBSOCKET:
```typescript
// Mapa de conexões WebSocket: deliveryId -> Set de conexões
const deliveryWebSocketClients: Record<string, Set<any>> = {}

// Endpoint WebSocket
fastify.get('/ws/:deliveryId', { websocket: true }, (connection, request) => {
  const { deliveryId } = request.params as { deliveryId: string }
  
  // Adiciona conexão ao set correspondente ao deliveryId
  if (!deliveryWebSocketClients[deliveryId]) {
    deliveryWebSocketClients[deliveryId] = new Set()
  }
  deliveryWebSocketClients[deliveryId].add(connection.socket)

  // Remove conexão quando cliente desconecta
  connection.socket.on('close', () => {
    deliveryWebSocketClients[deliveryId].delete(connection.socket)
    if (deliveryWebSocketClients[deliveryId].size === 0) {
      delete deliveryWebSocketClients[deliveryId]
    }
  })
})
```

2. BROADCAST DE LOCALIZAÇÕES:
```typescript
// Quando uma nova localização é enviada via API POST /api/locations
const wsClients = deliveryWebSocketClients[deliveryId]
if (wsClients && wsClients.size > 0) {
  const payload = JSON.stringify({
    id: location.id,
    deliveryId: location.deliveryId,
    latitude: location.latitude,
    longitude: location.longitude,
    timestamp: location.timestamp.toISOString()
  })
  
  // Envia para todos os clientes conectados
  wsClients.forEach((client) => {
    try {
      client.send(payload)
    } catch (e) {
      // Remove cliente se falhar
      wsClients.delete(client)
    }
  })
}
```

FRONTEND (Next.js + WebSocket)
------------------------------
Localização: frontend/app/deliveries/[id]/page.tsx

1. CONEXÃO COM WEBSOCKET:
```typescript
useEffect(() => {
  // WebSocket para atualizações em tempo real
  ws = new window.WebSocket(`ws://localhost:3001/api/locations/ws/${id}`)
  
  ws.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data)
      // Atualiza o estado das localizações
      if (Array.isArray(data)) {
        setLocations(data)
      } else if (data && data.latitude && data.longitude) {
        setLocations((prev) => [...prev, data])
      }
    } catch (e) {
      // Ignora mensagens não-JSON
    }
  }
  
  ws.onerror = (event) => {
    // Trata erros de conexão
  }

  return () => {
    if (ws) ws.close()
  }
}, [id])
```

FLUXO COMPLETO DE FUNCIONAMENTO
===============================

1. CLIENTE ABRE A PÁGINA DE DETALHES DA ENTREGA:
   - Frontend conecta ao WebSocket: `ws://localhost:3001/api/locations/ws/{deliveryId}`
   - Backend adiciona a conexão ao set correspondente ao deliveryId
   - Cliente está pronto para receber atualizações

2. ENTREGADOR ENVIA NOVA LOCALIZAÇÃO:
   - Script Python (ou app mobile) faz POST para `/api/locations`
   - Backend salva a localização no banco de dados
   - Backend busca todos os clientes conectados ao deliveryId
   - Backend envia a nova localização para todos os clientes via WebSocket

3. FRONTEND RECEBE E ATUALIZA:
   - Frontend recebe mensagem via WebSocket
   - Parseia o JSON da localização
   - Atualiza o estado React (setLocations)
   - Mapa é re-renderizado com nova posição
   - Trajeto é atualizado em tempo real

4. MÚLTIPLOS CLIENTES:
   - Vários usuários podem acompanhar a mesma entrega
   - Cada conexão é independente
   - Broadcast garante que todos recebam as atualizações

VANTAGENS DESTA IMPLEMENTAÇÃO
=============================

1. TEMPO REAL EFICIENTE:
   - Sem polling desnecessário
   - Atualizações instantâneas
   - Baixo consumo de recursos

2. ESCALABILIDADE:
   - Múltiplos clientes por entrega
   - Conexões independentes
   - Limpeza automática de conexões fechadas

3. FALLBACK ROBUSTO:
   - Polling como backup se WebSocket falhar
   - Tratamento de erros de conexão
   - Reconexão automática

4. SEGURANÇA:
   - WebSocket protegido por autenticação
   - Validação de deliveryId
   - Controle de acesso por usuário

EXEMPLO PRÁTICO DE USO
======================

CENÁRIO: Cliente acompanhando entrega em tempo real

1. Cliente faz login e acessa detalhes da entrega #123
2. Frontend conecta: `ws://localhost:3001/api/locations/ws/123`
3. Entregador se move e script Python envia nova localização
4. Backend recebe via API e faz broadcast via WebSocket
5. Frontend recebe e atualiza mapa instantaneamente
6. Cliente vê o entregador se movendo em tempo real

CONFIGURAÇÃO E DEPLOY
=====================

DESENVOLVIMENTO:
- WebSocket: ws://localhost:3001/api/locations/ws/{id}
- CORS configurado para aceitar conexões do frontend

PRODUÇÃO:
- WebSocket: wss://seudominio.com/api/locations/ws/{id} (HTTPS)
- Load balancer configurado para WebSockets
- SSL/TLS obrigatório para conexões seguras

MONITORAMENTO:
- Logs de conexões/desconexões
- Métricas de clientes conectados por entrega
- Alertas para falhas de conexão

LIMITAÇÕES E CONSIDERAÇÕES
==========================

1. CONEXÕES PERSISTENTES:
   - Consome recursos do servidor
   - Timeout de conexões inativas
   - Limpeza de conexões órfãs

2. ESCALABILIDADE:
   - Múltiplos servidores precisam de sincronização
   - Redis para compartilhar estado entre instâncias
   - Load balancer com sticky sessions

3. FALLBACK:
   - Clientes sem suporte a WebSocket
   - Conexões instáveis
   - Polling como alternativa

4. SEGURANÇA:
   - Rate limiting para conexões
   - Validação de origem
   - Autenticação robusta

ALTERNATIVAS E MELHORIAS
========================

1. SERVER-SENT EVENTS (SSE):
   - Alternativa mais simples para broadcast
   - Apenas servidor → cliente
   - Melhor para muitos clientes

2. POLLING INTELIGENTE:
   - Intervalo adaptativo
   - Baseado em atividade da entrega
   - Economia de recursos

3. PUSH NOTIFICATIONS:
   - Para atualizações importantes
   - Integração com service workers
   - Notificações mesmo com app fechado

4. WEBSOCKET CLUSTER:
   - Múltiplas instâncias
   - Redis para sincronização
   - Alta disponibilidade

CONCLUSÃO
=========
Os WebSockets no Delivery Track proporcionam uma experiência de rastreamento em tempo real eficiente e escalável. A implementação atual garante baixa latência, múltiplos clientes simultâneos e robustez com fallbacks apropriados. 